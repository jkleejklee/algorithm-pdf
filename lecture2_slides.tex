\documentclass{beamer}
\usepackage{ctex}
\usepackage[export]{adjustbox}
\usetheme{focus}

\title{算法分析与设计II}
\subtitle{2022-2023-2}
\date{Last Modified: 2023.1.16}
\institute{\vspace{2em} 数学与计算机学院 \\ 数据科学与大数据技术}
\titlegraphic{\vspace{5em} \includegraphics[scale=0.3]{fig/jlnu.pdf}}

\begin{document}

\frame{\titlepage}

\section{2. 基础算法}
\begin{frame}{2.1 枚举法}
    \begin{block}{枚举法}
        也叫穷举法,是一种\textcolor{blue}{暴力搜索}的方法,特点是将给定条件的所有情况都进行计算,直到找到符合要求的解, 随着参与计算的参数的增加,算法复杂度可能成指数级增加,所以只有当所有情况的总数在一个较小的范围时才能进行
    \end{block}
    \vfill
    \begin{itemize}
        \item 枚举法的优点就是建模简单,几乎不用考虑任何算法。在计算过程中,排除一些不可能的情况,能够适当减少一定的计算量
        \item 程序设计中一些\textcolor{blue}{排序算法}(选择排序、冒泡排序、插入排序)、\textcolor{blue}{查找算法}(顺序查找、二叉树的遍历等)都是枚举法的具体应用
    \end{itemize}
\end{frame}
\begin{frame}{2363 -- Blocks (poj.org)}
    \begin{itemize}
        \item Description
        \begin{itemize}
            \item ...Each block is a cube, 1 inch by 1 inch by 1 inch. Donald wants to stack the blocks together into a rectangular solid and wrap them all up in brown paper for shipping. How much brown paper does Donald need?
        \end{itemize}
        \item Input
        \begin{itemize}
            \item The first line of input contains C, the number of test cases. For each case there is an additional line containing N, the number of blocks to be shipped. N does not exceed 1000.
        \end{itemize}
        \item Output
        \begin{itemize}
            \item Your program should produce one line of output per case, giving the minimal area of paper (in square inches) needed to wrap the blocks when they are stacked together.
        \end{itemize}
    \end{itemize}
\end{frame}
\begin{frame}
    \begin{exampleblock}{Sample}
        \begin{itemize}
            \item Sample Input: 10
            \item Sample Output: 34
        \end{itemize}
    \end{exampleblock}
    \vfill
    \includegraphics[scale=0.7]{fig/2-1.png}
\end{frame}
\begin{frame}{2.2 递归法}
    \begin{itemize}
        \item 递归法思路:
        \begin{enumerate}
            \item 原问题分解为一个或多个规模更小、但具有类似于原问题特性的子问题
            \item 确定无须分解、可直接求解的最小子问题（递归的终止条件）
        \end{enumerate}
        \item 递归的两个基本要素是：
        \begin{enumerate}
            \item 递归关系式：确定递归的方式，即原问题是如何分解为子问题的
            \item 递归出口：确定递归到何时终止，即递归的终止（结束、边界）条件
        \end{enumerate}
        \item 但是，递归方法并不能降低程序的时间复杂度，而且，递归时函数的嵌套调用使用系统堆栈，控制不好会导致\alert{堆栈溢出} (stack overflow)
    \end{itemize}
\end{frame}
\begin{frame}{2255 -- Tree Recovery (poj.org)}
    \begin{itemize}
        \item 已知二叉树
        \begin{itemize}
            \item 先序遍历为DBACEGF
            \item 中序遍历为ABCDEFG
        \end{itemize}
        \item 求后序遍历
        \begin{itemize}
            \item ACBFGED
        \end{itemize}
    \end{itemize}
    \includegraphics[width=0.5\textwidth, right]{fig/2-2.png}
\end{frame}
\begin{frame}{1731 -- Orders (poj.org)}
    \begin{itemize}
        \item 给出字母序列，将这个序列中字母组成的所有可能排列/置换按字典序输出
    \end{itemize}
    \vfill
    \begin{exampleblock}{Sample}
        \begin{itemize}
            \item Sample Input: bbjd
            \item Sample Output: bbdj bbjd bdbj bdjb bjbd bjdb dbbj dbjb djbb jbbd jbdb jdbb
        \end{itemize}
    \end{exampleblock}
    \vfill
    \begin{itemize}
        \item 实现：
        \begin{enumerate}
            \item 递归（手写）
            \item C++ STL中的next\_permutation函数
        \end{enumerate}
    \end{itemize}
\end{frame}
\begin{frame}{2.3 分治法}
    \begin{block}{分治法}
        将原问题分解成规模较小但是与原问题类似的子问题，通过递归来求解这些子问题，再将子问题的解合并来求出原问题的解的方法
    \end{block}
    \vfill
    \begin{itemize}
        \item 分治在递归的过程中有三步：
        \begin{enumerate}
            \item 分解：将原问题分解成规模较小但是与问题类似的子问题
            \item 求解：递归求解子问题，子问题规模足够小时直接求解
            \item 合并：将子问题的解合并，求出原问题的解
        \end{enumerate}
    \end{itemize}
\end{frame}
\begin{frame}{MapReduce}
    \includegraphics[scale=0.45]{fig/2-3.png}
\end{frame}
\begin{frame}{2388 -- Who's in the Middle (poj.org)}
    \begin{itemize}
        \item 求n个数的中位数，n为奇数
    \end{itemize}
    \vfill
    \begin{itemize}
        \item 分析
        \begin{enumerate}
            \item 如果n个数是有序的，那么第$\frac{n+1}{2}$个数就是所求的中位数
            \item 在C语言提供了排序函数qsort，C++语言提供了sort， 它们的实现都是基于快速排序
            \item \textcolor{blue}{快速排序}(Quicksort)，又称\textcolor{blue}{划分交换排序}(partition-exchange sort)，简称\textcolor{blue}{快排}
        \end{enumerate}
    \end{itemize}
\end{frame}
\begin{frame}{快速排序}
    \begin{columns}
        \column{0.3\textwidth}
            \includegraphics[scale=0.4]{fig/2-4.png}
        \column{0.7\textwidth}
        \begin{enumerate}[(1)]
            \item 选取数组a最右边元素作为基准值x，两个指针i和j最初都在序列最左边
            \pause
            \item 用a[j]和x的值进行比较，如果a[j]小于x，则交换a[i]和a[j]，同时将i和j向右移动；如果a[j]大于等于x，则j右移，i不动
            \pause
            \item 当j移动到最右边时，i的左侧元素都小于x，右侧都大于等于x
            \pause
            \item 最后将x和a[i]值交换。序列就被i分成了左右两部分
            \pause
        \end{enumerate}
        \begin{itemize}
            \item 交换过程结束后，两个3改变了之前的顺序，这种情况称为排序的不稳定性，所以这种快速排序算法是不稳定的排序算法
        \end{itemize}
    \end{columns}
\end{frame}


\end{document}